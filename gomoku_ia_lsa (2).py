# -*- coding: utf-8 -*-
"""GOMOKU  IA - LSA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CGf9LBwxHgHc8kP3HowSR1aach3gu9Gv
"""

import time

CHRONOMETRE = [0, 0]
LIGNES = "ABCDEFGHIJKLMNO"
COLONNES = [str(i) for i in range(0, 15)]

# Initialisation cases plateau
PLATEAU_JEU = {ligne + colonne: ' ' for ligne in LIGNES for colonne in COLONNES}

# Calcul voisins
VOISINS_CASES = {case: set([case]) for case in PLATEAU_JEU}
for case in VOISINS_CASES:
    indice_ligne = LIGNES.index(case[0])
    indice_colonne = COLONNES.index(case[1:])
    voisins = []
    if indice_colonne - 1 >= 0:
        voisins.append(LIGNES[indice_ligne] + COLONNES[indice_colonne - 1])
        if indice_ligne - 1 >= 0:
            voisins.append(LIGNES[indice_ligne - 1] + COLONNES[indice_colonne - 1])
        if indice_ligne + 1 <= 14:
            voisins.append(LIGNES[indice_ligne + 1] + COLONNES[indice_colonne - 1])
    if indice_colonne + 1 <= 14:
        voisins.append(LIGNES[indice_ligne] + COLONNES[indice_colonne + 1])
        if indice_ligne - 1 >= 0:
            voisins.append(LIGNES[indice_ligne - 1] + COLONNES[indice_colonne + 1])
        if indice_ligne + 1 <= 14:
            voisins.append(LIGNES[indice_ligne + 1] + COLONNES[indice_colonne + 1])
    if indice_ligne - 1 >= 0:
        voisins.append(LIGNES[indice_ligne - 1] + COLONNES[indice_colonne])
    if indice_ligne + 1 <= 14:
        voisins.append(LIGNES[indice_ligne + 1] + COLONNES[indice_colonne])
    VOISINS_CASES[case].update(voisins)

# Affiche la grille
def afficher_plateau_jeu(plateau=PLATEAU_JEU):
    """Affiche une grille bien centrée et lisible."""
    largeur_case = 3
    separateur = "-" * (largeur_case * len(COLONNES) + len(COLONNES) + 1)

    # tête colonnes
    print("   " + " ".join(f"{colonne:>{largeur_case}}" for colonne in COLONNES))
    print("   " + separateur)

    # Affiche chaque ligne
    for ligne in LIGNES:
        contenu_ligne = f" {ligne} |" + "|".join(f"{plateau[ligne + colonne]:^{largeur_case}}" for colonne in COLONNES) + "|"
        print(contenu_ligne)
        print("   " + separateur)

ALIGNEMENTS = {}
INDICE_ALIGNEMENT = 0

# Alignements horizontaux
for ligne in LIGNES:
    for indice_colonne in range(len(COLONNES) - 4):
        alignement = '-'.join(ligne + COLONNES[indice_colonne + decalage] for decalage in range(5))
        ALIGNEMENTS[alignement] = INDICE_ALIGNEMENT
        INDICE_ALIGNEMENT += 1

# Alignements verticaux
for colonne in COLONNES:
    for indice_ligne in range(len(LIGNES) - 4):
        alignement = '-'.join(LIGNES[indice_ligne + decalage] + colonne for decalage in range(5))
        ALIGNEMENTS[alignement] = INDICE_ALIGNEMENT
        INDICE_ALIGNEMENT += 1

# Alignements diagonaux
for indice_ligne in range(len(LIGNES) - 4):
    for indice_colonne in range(len(COLONNES) - 4):
        alignement = '-'.join(LIGNES[indice_ligne + decalage] + COLONNES[indice_colonne + decalage] for decalage in range(5))
        ALIGNEMENTS[alignement] = INDICE_ALIGNEMENT
        INDICE_ALIGNEMENT += 1

# Alignements en diagonale inverse
for indice_ligne in range(4, len(LIGNES)):
    for indice_colonne in range(len(COLONNES) - 4):
        alignement = '-'.join(LIGNES[indice_ligne - decalage] + COLONNES[indice_colonne + decalage] for decalage in range(5))
        ALIGNEMENTS[alignement] = INDICE_ALIGNEMENT
        INDICE_ALIGNEMENT += 1

# Variables pour suivre le jeu
APTITUDE_ALIGNEMENT = [[set() for _ in range(5)], [set() for _ in range(5)], set(ALIGNEMENTS.values())]
CASES_JOUABLES_PAR_ALIGNEMENT = {ALIGNEMENTS[cle]: set(cle.split('-')) for cle in ALIGNEMENTS}
ALIGNEMENTS_PAR_CASE = {case: [] for case in PLATEAU_JEU}
for case in PLATEAU_JEU:
    for alignement in ALIGNEMENTS:
        if case in alignement.split('-'):
            ALIGNEMENTS_PAR_CASE[case].append(ALIGNEMENTS[alignement])

SYMBOLS_JOUEURS = ['X', 'O']

def calculer_aptitude(aptitude_alignement):
    """Évalue la force d'une position."""
    POIDS = [10000, 100, 50, 10, 1]
    score = sum((len(aptitude_alignement[0][k]) - len(aptitude_alignement[1][k])) * POIDS[k] for k in range(5))
    score -= len(aptitude_alignement[1][1]) * 1000
    return score

def jeu_termine(etat_jeu): # Cherche un alignement
    """Vérifie si un joueur a gagné ou si le jeu est terminé."""
    aptitude, _ = etat_jeu #  si Liste aptitude non vide, alors joueur gagne
    if len(aptitude[0][0]) > 0: #  aptitude [0] Joueur 0
        print("\nVictoire : IA gagne.")
        return True
    if len(aptitude[1][0]) > 0: # aptitude [1] Joueur 1
        print("\nVictoire : Joueur gagne.")
        return True
    return False

def mettre_a_jour_etat_jeu(etat_jeu, case_jouee, joueur_actuel): # Met a jour après que le joueur joue une case
    """Met à jour la situation après un coup joué."""
    adversaire = (joueur_actuel + 1) % 2 # Joueur actuel 0 (IA) ou 1.
    aptitude_mise_a_jour = [[etat_jeu[0][0][i].copy() for i in range(5)],
                            [etat_jeu[0][1][i].copy() for i in range(5)],
                            etat_jeu[0][2].copy()]
    cases_jouees = etat_jeu[1].copy()
    for alignement in ALIGNEMENTS_PAR_CASE[case_jouee]: # Parcours les cases jouées
        if alignement in aptitude_mise_a_jour[2]:
            aptitude_mise_a_jour[joueur_actuel][4].add(alignement)
            aptitude_mise_a_jour[2].discard(alignement)
            continue
        for k in range(1, 5):
            aptitude_mise_a_jour[adversaire][k].discard(alignement)
            if alignement in aptitude_mise_a_jour[joueur_actuel][k]:
                aptitude_mise_a_jour[joueur_actuel][k].discard(alignement)
                aptitude_mise_a_jour[joueur_actuel][k - 1].add(alignement)
                break
    cases_jouees.add(case_jouee)
    return aptitude_mise_a_jour, cases_jouees

def detecter_coups_critiques(etat_jeu, joueur):
    """Détecte les coups permettant de gagner ou de bloquer immédiatement."""
    aptitude, cases_jouees = etat_jeu
    coups_critiques = set()
    for alignement in aptitude[joueur][1]: # Regarde les alignements qu'il a
        coups_critiques.update(CASES_JOUABLES_PAR_ALIGNEMENT[alignement])
    for alignement in aptitude[(joueur + 1) % 2][1]: #Regarde les alignements qu'à l'adversaire
        coups_critiques.update(CASES_JOUABLES_PAR_ALIGNEMENT[alignement])
    coups_critiques.difference_update(cases_jouees)
    return coups_critiques

def recherche_alpha_beta(etat_jeu): # Recherche le meilleur coup Possile
    """Effectue une recherche alpha-bêta pour trouver le meilleur coup."""
    coups_critiques = detecter_coups_critiques(etat_jeu, 0)
    if coups_critiques:
        print(f"IA détecte un coup critique : {coups_critiques}") # Si elle detcte coup critique elle joue direct
        return 0, coups_critiques.pop()
    return valeur_max(etat_jeu, -100000, 100000, 1) # sinon recherches le poids max

def valeur_max(etat_jeu, alpha, beta, profondeur): # INF PIRE cas pour l'IA
    if jeu_termine(etat_jeu) or profondeur >= 3:
        return calculer_aptitude(etat_jeu[0]), None
    valeur = -float('inf')
    meilleur_action = None
    for action in generer_coups_valides(etat_jeu, 0):
        val_min, _ = valeur_min(mettre_a_jour_etat_jeu(etat_jeu, action, 0), alpha, beta, profondeur + 1)
        if val_min > valeur:
            valeur = val_min
            meilleur_action = action
        if valeur >= beta:
            return valeur, meilleur_action
        alpha = max(alpha, valeur)
    return valeur, meilleur_action

def valeur_min(etat_jeu, alpha, beta, profondeur): # INF pire cas pour l'adversaire
    if jeu_termine(etat_jeu) or profondeur >= 3:
        return calculer_aptitude(etat_jeu[0]), None
    valeur = float('inf')
    for action in generer_coups_valides(etat_jeu, 1):
        val_max, _ = valeur_max(mettre_a_jour_etat_jeu(etat_jeu, action, 1), alpha, beta, profondeur + 1)
        if val_max < valeur:
            valeur = val_max
        if valeur <= alpha:
            return valeur, None
        beta = min(beta, valeur)
    return valeur, None

def generer_coups_valides(etat_jeu, joueur):
    """Génère les coups valides pour un joueur donné."""
    aptitude, cases_jouees = etat_jeu
    coups_valides = set()
    for alignement in aptitude[joueur][4]:
        coups_valides.update(CASES_JOUABLES_PAR_ALIGNEMENT[alignement])
    for case in cases_jouees:
        coups_valides.update(VOISINS_CASES[case])
    coups_valides.difference_update(cases_jouees)
    return coups_valides

def jouer_partie():
    """Lance une partie."""
    global PLATEAU_JEU
    plateau_jeu = PLATEAU_JEU.copy()
    premier_joueur = int(input("Qui commence ? (0: IA, 1: Joueur) : "))
    etat_jeu = APTITUDE_ALIGNEMENT, set()
    etat_jeu = mettre_a_jour_etat_jeu(etat_jeu, 'H7', premier_joueur)
    plateau_jeu['H7'] = SYMBOLS_JOUEURS[premier_joueur]
    tour = (premier_joueur + 1) % 2
    compteur_tours_ia = 0  # Compteur pour les tours de l'IA

    while not jeu_termine(etat_jeu):
        if tour == 1:
            # Tour du joueur humain
            case = input(f"\nJoueur, entrez votre coup (par ex : H9) : ")
        else:
            # Tour de l'IA
            if compteur_tours_ia == 1:  # Vérifier si c'est le 2ème tour de l'IA
                case = 'A2'  # Forcer l'IA à jouer A2
                print("\nIA joue : A2 (coup forcé au 2ème tour de l'IA)")
            else:
                # Jouer normalement en utilisant l'algorithme
                _, case = recherche_alpha_beta(etat_jeu)
                print(f"\nIA joue : {case}")

        if case not in PLATEAU_JEU or case in etat_jeu[1]:
            print("Coup invalide. Réessayez.")
            continue

        # Met à jour l'état du jeu et le plateau
        etat_jeu = mettre_a_jour_etat_jeu(etat_jeu, case, tour)
        plateau_jeu[case] = SYMBOLS_JOUEURS[tour]
        afficher_plateau_jeu(plateau_jeu)

        # Passe au tour suivant
        if tour == 0:
            compteur_tours_ia += 1  # Incrément le compteur des tours de l'IA
        tour = (tour + 1) % 2

    print("Partie terminée.")

if __name__ == "__main__":
    jouer_partie()